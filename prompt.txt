I need a go program within a docker container, that subscribes to inotify events, when a file is created in a specified folder (via env. var) and post them to the paperless-ngx api. Consider the following requirements:

- the application sahll read a path from an evironment variable and subscribe to file creations for that path via inotify
- at application start, it shall checks for already existing files in the watched folder and post them to the internal processing queue
- the upload to Paperless-ngx shall be done via a multipart http request (consider api description below) 
- once a new file has been detected inside the watched folder, an event with the path shall be sent to a go channel called fileStabilityConfirmation pending
- a consumer shall take the events from fileStabilityConfirmation and watch the files in parrallel for a consisten filesize over multiple cycles
- when the filesize has not changed of the configureed amont of time/cycles, an event with the path shall be sent to the go channel readyForUpload
- a consumer shall take the events from the channel readyForUpload and upload the file to paperless-ngx. when done, the file shall be deleted and the next file/event from the channel shall be processed.
- if paperless-ngx responds with 200 to the file upload, the original file shall be deleted 
- once a file appears in the watched folder, the applicaation shall monitor the size and filename for changes to confirm that the file is complete. 
- the retry and delay values to wait or a complete file shall have a good default but shall be configurable via an env var. 
- there must be a number of consecutive checks (configuratble, with default), with the same filesize to confirm a stable file 
- there shall be not more than 1 upload to paperless-ngx in parallel 
- If the paperless-ngx api is not available (timeout) or indicate a server issue, there shall be an infinite amount of retries. 
- The delay between consecutive retries shall be configurable via env vars but shall have a default value
- the base path to paperless-ngx shall be configurable via an enviroment variable to be used for api path construction
- if the base path has a trailing slash, it shall still contruct the correct url (replace // with / )
- if a non-optional environment variable is missing, the application shall interrupt it's start, indicating clearly what is missing.
- all logs shall be written to stdout
- the applciation shall be instrumented with probes for providing an prometheus endpoint. Add some useful counters (e.g. successful/failed http requests; imported files; ...)
- a health and radiness endpoint shall be avaialble
- all functionctionaly shall be implemented

Consider the following api description from paperless-ngx for constructing the multipart http request to paperless-ngx: POSTing documents The API provides a special endpoint for file uploads:

/api/documents/post_document/

POST a multipart form to this endpoint, where the form field document contains the document that you want to upload to paperless. The filename is sanitized and then used to store the document in a temporary directory, and the consumer will be instructed to consume the document from there.

The endpoint supports the following optional form fields:

title: Specify a title that the consumer should use for the document. created: Specify a DateTime where the document was created (e.g. "2016-04-19" or "2016-04-19 06:15:00+02:00"). correspondent: Specify the ID of a correspondent that the consumer should use for the document. document_type: Similar to correspondent. storage_path: Similar to correspondent. tags: Similar to correspondent. Specify this multiple times to have multiple tags added to the document. archive_serial_number: An optional archive serial number to set. custom_fields: An array of custom field ids to assign (with an empty value) to the document. The endpoint will immediately return HTTP 200 if the document consumption process was started successfully, with the UUID of the consumption task as the data. No additional status information about the consumption process itself is available immediately, since that happens in a different process. However, querying the tasks endpoint with the returned UUID e.g. /api/tasks/?task_id={uuid} will provide information on the state of the consumption including the ID of a created document if consumption succeeded.